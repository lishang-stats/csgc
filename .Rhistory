devtools::document
devtools::document()
set.seed(123)
library(csgc)
k = 4
n = 100
K = matrix(c(0.8, 0.5, 0.1, 0.1,
0.5, 0.1, 0.1, 0.1,
0.1, 0.1, 0.8, 0.5,
0.1, 0.1, 0.5, 0.1),4,4)
z = rep(1:k,each=n/k)
mat = gen_adj_sbm(K,z)
A = mat$A
P = mat$P
data(faux.dixon.high, package="ergm")
fit <- ergm::ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
csgc(out$A, out$P)$t
data(Books, package="greed")
sbm = greed::greed(Books$X, model = Sbm())
library(greed)
greed(Books$X, model=Sbm())
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
csgc(out1$A, out1$P, out1$modeltype)$t
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
csgc(out1$A, out1$P, out1$modeltype)$t
data(Books, package="greed")
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
data(karate, package="igraphdata")
karate = data(karate, package="igraphdata")
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
data(Books, package="greed")
Books@X
Books$X
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- invisible(blockmodels::BM_bernoulli("SBM",M ))
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- invisible(blockmodels::BM_bernoulli("SBM",M ))
out = A_P_from_blockmodels(model=fit)
library(csgc)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- invisible(blockmodels::BM_bernoulli("SBM",M ))
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
capture.output(fit <- blockmodels::BM_bernoulli("SBM",M ))
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
dev.off()
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
library(csgc)
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
fit <- blockmodels::BM_bernoulli("SBM",M )
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
dev.off()
library(blockmodels)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
fit$estimate()
fit$estimate()
model$ICL
fit$ICL
fit$memberships
fit$memberships[[1]]
fit$memberships[[1]]$Z
model = fit
model$estimate()
k = which.max(model$ICL)
z = apply(model$memberships[[k]]$Z,1,which.max)
K = model$model_parameters[[k]]$pi
P = K[z,z]
modeltype = model$model_name
if (model$membership_name %in% c("SBM", "SBM_sym") &
model$model_name %in% c("bernoulli", "poisson")){
A = model$adj
if (model$membership_name == "SBM"){
A[upper.tri(A)] = pmax(A[upper.tri(A)], t(A)[upper.tri(A)])
A[lower.tri(A)] = t(A)[lower.tri(A)]
warning("Convert directed graph to undirected graph.")
}
model$estimate()
k = which.max(model$ICL)
z = apply(model$memberships[[k]]$Z,1,which.max)
K = model$model_parameters[[k]]$pi
P = K[z,z]
modeltype = model$model_name
return(list(A=A,P=P,modeltype=modeltype))
} else{
stop("Input model must be stochastic block model with distribution bernoulli
or poisson!")
}
if (model$membership_name %in% c("SBM", "SBM_sym") &
model$model_name %in% c("bernoulli", "poisson")){
A = model$adj
if (model$membership_name == "SBM"){
A[upper.tri(A)] = pmax(A[upper.tri(A)], t(A)[upper.tri(A)])
A[lower.tri(A)] = t(A)[lower.tri(A)]
warning("Convert directed graph to undirected graph.")
}
model$estimate()
k = which.max(model$ICL)
z = apply(model$memberships[[k]]$Z,1,which.max)
K = model$model_parameters[[k]]$pi
P = K[z,z]
modeltype = model$model_name
return(list(A=A,P=P,modeltype=modeltype))
}
model
if (model$membership_name %in% c("SBM", "SBM_sym") &
model$model_name %in% c("bernoulli", "poisson")){
A = model$adj
if (model$membership_name == "SBM"){
A[upper.tri(A)] = pmax(A[upper.tri(A)], t(A)[upper.tri(A)])
A[lower.tri(A)] = t(A)[lower.tri(A)]
warning("Convert directed graph to undirected graph.")
}
model$estimate()
k = which.max(model$ICL)
z = apply(model$memberships[[k]]$Z,1,which.max)
K = model$model_parameters[[k]]$pi
P = K[z,z]
modeltype = model$model_name
}
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
dev.off()
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
pdf(file = NULL);dev.off()
renv::init()
file.edit("R/A_P_from_blockmodels.R")
library(csgc)
devtools::document()
library(csgc)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M, plotting='')
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M, plotting='')
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
Books$X
out1 = A_P_from_greed(data=(Books$X), blockmodel=sbm)
library(csgc)
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
d = Books$X
out1 = A_P_from_greed(data=d, blockmodel=sbm)
coef(sbm)
sbm@cl
sbm@logalpha
sbm@path
sbm@icl
sbm@coef
coef(sbm)
packageVersion("greede")
packageVersion("greed")
coef(sbm)
library(greed)
coef(sbm)
# install.packages(c("ergm", "blockmodels", "greed", "igraphdata"))
library(c("ergm", "blockmodels", "greed", "igraphdata"))
# install.packages(c("ergm", "blockmodels", "greed", "igraphdata"))
library(ergm)
library(blockmodels)
library(greed)
library(igraphdata)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
set.seed(123)
library(csgc)
k = 4
n = 100
K = matrix(c(0.8, 0.5, 0.1, 0.1,
0.5, 0.1, 0.1, 0.1,
0.1, 0.1, 0.8, 0.5,
0.1, 0.1, 0.5, 0.1),4,4)
z = rep(1:k,each=n/k)
mat = gen_adj_sbm(K,z)
A = mat$A
P = mat$P
mat2 = sbm_mle(A,z)
Khat = mat2$K
Phat = mat2$P
zhat = spectral_sbm(A,4)
ccrate = ccr(z,zhat)
ccrate
Phat2 = sbm_mle(A,zhat)$P
t = csgc(A,Phat2,"bernoulli")$t
t
p = runif(100)
wasserstein_uniform(p)
Theta = runif(n,.2,1)
dmat = gen_adj_dcsbm(K,Theta,z)
dA = dmat$A
dP = dmat$P
dmat2 = dcsbm_mle(dA,z)
dPhat = mat2$P
dzhat = spectral_dcsbm(dA,4)
dccrate = ccr(z,dzhat)
dccrate
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
set.seed(123)
library(csgc)
k = 4
n = 100
K = matrix(c(0.8, 0.5, 0.1, 0.1,
0.5, 0.1, 0.1, 0.1,
0.1, 0.1, 0.8, 0.5,
0.1, 0.1, 0.5, 0.1),4,4)
z = rep(1:k,each=n/k)
mat = gen_adj_sbm(K,z)
A = mat$A
P = mat$P
mat2 = sbm_mle(A,z)
Khat = mat2$K
Phat = mat2$P
zhat = spectral_sbm(A,4)
ccrate = ccr(z,zhat)
ccrate
Phat2 = sbm_mle(A,zhat)$P
t = csgc(A,Phat2,"bernoulli")$t
t
p = runif(100)
wasserstein_uniform(p)
Theta = runif(n,.2,1)
dmat = gen_adj_dcsbm(K,Theta,z)
dA = dmat$A
dP = dmat$P
dmat2 = dcsbm_mle(dA,z)
dPhat = mat2$P
dzhat = spectral_dcsbm(dA,4)
dccrate = ccr(z,dzhat)
dccrate
# install.packages(c("ergm", "blockmodels", "greed", "igraphdata"))
library(ergm)
library(blockmodels)
library(greed)
library(igraphdata)
data(faux.dixon.high)
fit <- ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
csgc(out$A, out$P)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- BM_bernoulli("SBM",M, plotting='')
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
data(Books, package=)
sbm = greed(Books$X, model = Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
csgc(out1$A, out1$P, out1$modeltype)$t
karate = data(karate)
dcsbm = greed(karate, model= DcSbm())
data(karate)
dcsbm = greed(karate, model= DcSbm())
out2 = A_P_from_greed(data=karate, blockmodel=dcsbm)
csgc(out2$A, out2$P, out2$modeltype)$t
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
fig.path = "man/figures/README-",
out.width = "100%"
)
set.seed(123)
library(csgc)
k = 4
n = 100
K = matrix(c(0.8, 0.5, 0.1, 0.1,
0.5, 0.1, 0.1, 0.1,
0.1, 0.1, 0.8, 0.5,
0.1, 0.1, 0.5, 0.1),4,4)
z = rep(1:k,each=n/k)
mat = gen_adj_sbm(K,z)
A = mat$A
P = mat$P
mat2 = sbm_mle(A,z)
Khat = mat2$K
Phat = mat2$P
zhat = spectral_sbm(A,4)
ccrate = ccr(z,zhat)
ccrate
Phat2 = sbm_mle(A,zhat)$P
t = csgc(A,Phat2,"bernoulli")$t
t
p = runif(100)
wasserstein_uniform(p)
Theta = runif(n,.2,1)
dmat = gen_adj_dcsbm(K,Theta,z)
dA = dmat$A
dP = dmat$P
dmat2 = dcsbm_mle(dA,z)
dPhat = mat2$P
dzhat = spectral_dcsbm(dA,4)
dccrate = ccr(z,dzhat)
dccrate
# install.packages(c("ergm", "blockmodels", "greed", "igraphdata"))
library(ergm)
library(blockmodels)
library(greed)
library(igraphdata)
data(faux.dixon.high)
fit <- ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
csgc(out$A, out$P)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- BM_bernoulli("SBM",M, plotting='')
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
data(Books)
sbm = greed(Books$X, model = Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
csgc(out1$A, out1$P, out1$modeltype)$t
renv::init()
R cmd install cum
devtools::build()
renv::init()
file.edit("R/sbm_mle.R")
library(csgc)
devtools::document()
library(csgc)
devtools::document()
library(csgc)
devtools::build()
devtools::build()
renv::init()
renv::init()
devtools::build()
