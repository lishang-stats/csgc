data(ecoli)
data(florentine)
as.matrix(flobusiness)
as.matrix(flomarriage)
data(samplk)
dim(as.matrix(samplk1))
dim(as.matrix(samplk2))
dim(as.matrix(samplk3))
data(faux.dixon.high)
dixon.fit <- ergm(original.net ~ edges + mutual +
absdiff("grade") + nodefactor("race", base=5) + nodefactor("grade", base=3)
+ nodefactor("sex") + nodematch("race", diff = TRUE) + nodematch("grade",
diff = TRUE) + nodematch("sex", diff = FALSE) + idegree(0:1) + odegree(0:1)
+ gwesp(0.1,fixed=T), constraints = ~bd(maxout=10), control =
control.ergm(MCMLE.steplength = .25, MCMC.burnin = 100000, MCMC.interval =
10000, MCMC.samplesize = 2500, MCMLE.maxit = 100), verbose=T)
dixon.fit <- ergm(faux.dixon.high ~ edges + mutual +
absdiff("grade") + nodefactor("race", base=5) + nodefactor("grade", base=3)
+ nodefactor("sex") + nodematch("race", diff = TRUE) + nodematch("grade",
diff = TRUE) + nodematch("sex", diff = FALSE) + idegree(0:1) + odegree(0:1)
+ gwesp(0.1,fixed=T), constraints = ~bd(maxout=10), control =
control.ergm(MCMLE.steplength = .25, MCMC.burnin = 100000, MCMC.interval =
10000, MCMC.samplesize = 2500, MCMLE.maxit = 100), verbose=T)
dixon.fit <- ergm(faux.dixon.high ~ edges + mutual +
absdiff("grade") + nodefactor("race", base=5) + nodefactor("grade", base=3)
+ nodefactor("sex") + nodematch("race", diff = TRUE) + nodematch("grade",
diff = TRUE))
dixon.fit <- ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=dixon.fit)
dixon.fit$formula
dixon.fit$formula[[2]]
get.network.attribute(dixon.fit$formula[[2]],"hyper")
get.network.attribute(get(dixon.fit$formula[[2]]),"hyper")
data = get(dixon.fit$formula[[2]])
library(csgc)
library(csgc)
library(ergm)
data(faux.dixon.high)
fit <- ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
out$A
csgc(out$A, out$P)$t
sum(out$A)
library(ergm)
data(faux.dixon.high)
fit <- ergm(faux.dixon.high ~ edges)
out = A_P_from_ergm(model=fit)
csgc(out$A, out$P)$t
fit <- ergm(faux.dixon.high ~ edges + triangle)
fit <- ergm(faux.dixon.high ~ edges + cycle(4))
fit <- ergm(faux.dixon.high ~ edges + cycle(4, mutual))
fit <- ergm(faux.dixon.high ~ edges + cycle(4, semi=TRUE))
fit <- ergm(faux.dixon.high ~ edges + cycle(3, semi=TRUE))
dim(A)
dim(data)
library(csgc)
devtools::document()
file.create("R/A_P_from_blockmodels.R")
?A_P_from_ergm
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- BM_bernoulli("SBM",M )
library(blockmodels)
renv::init()
file.edit("R/A_P_from_blockmodels.R")
?A_P_from_ergm
??A_P_from_ergm
library(csgc)
devtools::document()
file.edit("R/A_P_from_ergm.R")
devtools::document()
?A_P_from_ergm
?A_P_from_blockmodels
renv::init()
file.edit("R/A_P_from_blockmodels.R")
file.create("R/A_P_from_greed.R")
renv::init()
file.edit("R/A_P_from_greed.R")
?A_P_from_ergm
??A_P_from_ergm
library(csgc)
library(greed)
usethis::use_package(greed)
usethis::use_package(package = "greed")
library(greed)
data(Books)
sbm = greed(Books$X, model = Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
library(igraphdata)
usethis::use_package(package = "igraphdata")
devtools::document()
renv::init()
file.edit
file.edit("R/A_P_from_blockmodels.R")
library(blockmodels)
uninstall("igraphdata")
remove.packages("igraphdata")
remove.packages("greed")
file.edit("R/A_P_from_greed.R")
renv::init()
file.edit("R/A_P_from_blockmodels.R")
file.edit("R/A_P_from_greed.R.R")
file.edit("R/A_P_from_greed.R")
library(greed)
data(Books)
use_description()
usethis::use_description()
getOption("usethis.description")
??A_P_from_greed
use_package(package, type = "Imports")
usethis::use_package(package, type = "Imports")
usethis::use_package(package, type = "Imports", min_version = 1.0.6)
remove.packages("rlang")
install.packages("rlang")
library(csgc)
renv::status()
renv::snapshot()
usethis::use_package(package = "renv", type = "Suggests")
library(csgc)
library(csgc)
renv::status()
renv::snapshot()
library(csgc)
library(greed)
devtools::document()
?A_P_from_greed
library(ergm)
data(faux.dixon.high)
fit <- ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
library(csgc)
library(ergm)
data(faux.dixon.high)
fit <- ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
csgc(out$A, out$P)$t
library(blockmodels)
install.packages("blockmodels")
library(blockmodels)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
library(greed)
install.packages("greed")
library(greed)
data(Books)
sbm = greed(Books$X, model = Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
library(igraphdata)
install.packages(igraphdata)
install.packages("igraphdata")
library(greed)
data(Books)
sbm = greed(Books$X, model = Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
library(igraphdata)
data(karate)
dcsbm = greed(karate, model=DcSbm())
out2 = A_P_from_greed(data=karate, blockmodel=dcsbm)
csgc(out1$A, out1$P, out1$modeltype)$t
csgc(out2$A, out2$P, out2$modeltype)$t
igraphdata::data(karate)
igraphdata::(data(karate))
?data
data(karte, package="igraphdata")
data(karate, package="igraphdata")
data(Books, package="greed")
sbm = greed::greed(Books$X, model = Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
csgc(out1$A, out1$P, out1$modeltype)$t
renv::status()
renv::snapshot()
renv::init()
renv::init()
file.edit("R/csgc_greedy.R")
library(csgc)
devtools::document()
data(faux.dixon.high, package="ergm")
fit <- ergm::ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
library(csgc)
data(faux.dixon.high, package="ergm")
fit <- ergm::ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
renv::init()
file.edit("R/A_P_from_ergm.R")
library(csgc)
devtools::document()
file.edit("R/A_P_from_ergm.R")
library(ergm)
data(faux.dixon.high)
fit <- ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
library(csgc)
devtools::document
devtools::document()
set.seed(123)
library(csgc)
k = 4
n = 100
K = matrix(c(0.8, 0.5, 0.1, 0.1,
0.5, 0.1, 0.1, 0.1,
0.1, 0.1, 0.8, 0.5,
0.1, 0.1, 0.5, 0.1),4,4)
z = rep(1:k,each=n/k)
mat = gen_adj_sbm(K,z)
A = mat$A
P = mat$P
data(faux.dixon.high, package="ergm")
fit <- ergm::ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
csgc(out$A, out$P)$t
data(Books, package="greed")
sbm = greed::greed(Books$X, model = Sbm())
library(greed)
greed(Books$X, model=Sbm())
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
csgc(out1$A, out1$P, out1$modeltype)$t
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
csgc(out1$A, out1$P, out1$modeltype)$t
data(Books, package="greed")
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
data(karate, package="igraphdata")
karate = data(karate, package="igraphdata")
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
data(Books, package="greed")
Books@X
Books$X
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- invisible(blockmodels::BM_bernoulli("SBM",M ))
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- invisible(blockmodels::BM_bernoulli("SBM",M ))
out = A_P_from_blockmodels(model=fit)
library(csgc)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- invisible(blockmodels::BM_bernoulli("SBM",M ))
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
capture.output(fit <- blockmodels::BM_bernoulli("SBM",M ))
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
dev.off()
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
library(csgc)
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
fit <- blockmodels::BM_bernoulli("SBM",M )
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
dev.off()
library(blockmodels)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
fit$estimate()
fit$estimate()
model$ICL
fit$ICL
fit$memberships
fit$memberships[[1]]
fit$memberships[[1]]$Z
model = fit
model$estimate()
k = which.max(model$ICL)
z = apply(model$memberships[[k]]$Z,1,which.max)
K = model$model_parameters[[k]]$pi
P = K[z,z]
modeltype = model$model_name
if (model$membership_name %in% c("SBM", "SBM_sym") &
model$model_name %in% c("bernoulli", "poisson")){
A = model$adj
if (model$membership_name == "SBM"){
A[upper.tri(A)] = pmax(A[upper.tri(A)], t(A)[upper.tri(A)])
A[lower.tri(A)] = t(A)[lower.tri(A)]
warning("Convert directed graph to undirected graph.")
}
model$estimate()
k = which.max(model$ICL)
z = apply(model$memberships[[k]]$Z,1,which.max)
K = model$model_parameters[[k]]$pi
P = K[z,z]
modeltype = model$model_name
return(list(A=A,P=P,modeltype=modeltype))
} else{
stop("Input model must be stochastic block model with distribution bernoulli
or poisson!")
}
if (model$membership_name %in% c("SBM", "SBM_sym") &
model$model_name %in% c("bernoulli", "poisson")){
A = model$adj
if (model$membership_name == "SBM"){
A[upper.tri(A)] = pmax(A[upper.tri(A)], t(A)[upper.tri(A)])
A[lower.tri(A)] = t(A)[lower.tri(A)]
warning("Convert directed graph to undirected graph.")
}
model$estimate()
k = which.max(model$ICL)
z = apply(model$memberships[[k]]$Z,1,which.max)
K = model$model_parameters[[k]]$pi
P = K[z,z]
modeltype = model$model_name
return(list(A=A,P=P,modeltype=modeltype))
}
model
if (model$membership_name %in% c("SBM", "SBM_sym") &
model$model_name %in% c("bernoulli", "poisson")){
A = model$adj
if (model$membership_name == "SBM"){
A[upper.tri(A)] = pmax(A[upper.tri(A)], t(A)[upper.tri(A)])
A[lower.tri(A)] = t(A)[lower.tri(A)]
warning("Convert directed graph to undirected graph.")
}
model$estimate()
k = which.max(model$ICL)
z = apply(model$memberships[[k]]$Z,1,which.max)
K = model$model_parameters[[k]]$pi
P = K[z,z]
modeltype = model$model_name
}
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
dev.off()
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
pdf(file = NULL);dev.off()
renv::init()
file.edit("R/A_P_from_blockmodels.R")
library(csgc)
devtools::document()
library(csgc)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M )
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M, plotting='')
out = A_P_from_blockmodels(model=fit)
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- blockmodels::BM_bernoulli("SBM",M, plotting='')
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
data(Books, package="greed")
sbm = greed::greed(Books$X, model = greed::Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
Books$X
out1 = A_P_from_greed(data=(Books$X), blockmodel=sbm)
