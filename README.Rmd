---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# csgc

<!-- badges: start -->
<!-- badges: end -->

The goal of csgc is to perform statistical analysis of network data based on centred subgraph counts.

## Installation

You can install the development version of csgc from [GitHub](https://github.com/) with:

``` r
install.packages("devtools")
devtools::install_github("lishang-stats/csgc")
```

## csgc: SBM

Assume an undirected unweighted network has $n$ vertices, with $A$ be the adjacency matrix and $P$ be the corresponding probability matrix. The parameter matrix $K$ (a $k$ by $k$ matrix) presents the connection probability within/between each block. Let $z$ be the label vector with length $n$, where each entry can be from $1$ to $k$. Consider the Bernoulli-type Stochastic Block Model
![equation](https://latex.codecogs.com/svg.latex?A_{ij}=A_{ji}\overset{i.i.d.}{\sim} \mathop{\mathrm{Be}}\left(k_{z_iz_j}\right))
for $1\leq i,j\leq n, i\ne j$. We first generate matrix $A$ and $P$ from $K$ and $z$.

```{r gen_sbm}
set.seed(123)
library(csgc)
k = 4
n = 100
K = matrix(c(0.8, 0.5, 0.1, 0.1,
             0.5, 0.1, 0.1, 0.1,
             0.1, 0.1, 0.8, 0.5,
             0.1, 0.1, 0.5, 0.1),4,4)
z = rep(1:k,each=n/k)
mat = gen_adj_sbm(K,z)
A = mat$A
P = mat$P
```

Then, we calculate the maximum likelihood estimated $K$ and $P$ from $A$ and true labels $z$.

```{r sbm_mle}
mat2 = sbm_mle(A,z)
Khat = mat2$K
Phat = mat2$P
```

We can also get the estimated labels given $A$ and number of communities $k$ using spectral clustering method, and compare the estimated labels with true labels.

```{r spectral}
zhat = spectral_sbm(A,4)
ccrate = ccr(z,zhat)
ccrate
```

If we use the estimated labels to further get the MLE for $P$, we can calculate the centred subgraph count statistics and check if these statistics are deviate from 0 or not.

```{r csgc}
Phat2 = sbm_mle(A,zhat)$P
t = csgc(A,Phat2,"bernoulli")$t
t
```

Sum of squares of these statistics should approximately follow a chi-square distribution if SBM fits the network data. Suppose we run the above simulation multiple times, we can get a batch of $p$-values, which are supposed to follow a uniform distribution. We can calculate the Wasserstein distance between these $p$-values and a uniform distribution on [0,1].

```{r dw}
p = runif(100)
wasserstein_uniform(p)
```

If these csgc statistics are deviate from 0, we can use our csgc greedy algorithm to adjust label estimations, and see if correct classification rate increases.

```{r greedy}
out = csgc_greedy(A,zhat,parallel=T)
zout = out$zout
chisqout = out$chisqout
statsout = out$statsout
chisqout
statsout
ccr(z,zout)
```

## csgc: DCSBM
Assume further that $\theta_i$ is the degree parameter for vertex $i$. Consider the Poisson-type Degree Corrected Stochastic Block Model
![equation](https://latex.codecogs.com/svg.latex?A_{ij}=A_{ji}\overset{i.i.d.}{\sim}%20\mathop{\mathrm{Po}}\left(\theta_i%20\theta_j%20k_{z_iz_j}\right))
for $1\leq i,j\leq n, i\ne j$. We can generate matrix $A$ and $P$ from $K$ and $\Theta$ and $z$.

```{r gen_dcsbm}
Theta = runif(n,.2,1)
dmat = gen_adj_dcsbm(K,Theta,z)
dA = dmat$A
dP = dmat$P
```

Though no closed form, numerical MLE for $P$ can be obtained, assuming $A$ and true labels $z$ are known.

```{r dcsbm_mle}
dmat2 = dcsbm_mle(dA,z)
dPhat = mat2$P
```

Using spectral clustering method for DCSBM, we can also get the estimated labels and with true labels.

```{r dcspectral}
dzhat = spectral_dcsbm(dA,4)
dccrate = ccr(z,dzhat)
dccrate
```

## csgc: Compatible with ergm/blockmodels/greed package
Finally, we make the csgc function compatible with other packages so that people can have easy access to these values. Before that, we will need the following packages: "ergm", "blockmodels", "greed" and "igraphdata".

```{r install_packages}
# install.packages(c("ergm", "blockmodels", "greed", "igraphdata"))
library(ergm)
library(blockmodels)
library(greed)
library(igraphdata)
```

For Exponential Random Graph Model, we can extract adjacency matrix (A) and predicted probability matrix (P), so that csgc statistics can be calculated.

```{r ergm}
data(faux.dixon.high)
fit <- ergm(faux.dixon.high ~ edges + mutual)
out = A_P_from_ergm(model=fit)
csgc(out$A, out$P)$t
```

For "blockmodels" object, we can easily extract adjacency matrix (A). The "blockmodels" package will estimate the number of communities (k), labels (z) and parameter matrix (K). From that, we can get the estimate probability matrix (P). 

```{r blockmodels}
npc <- 30 # nodes per class
Q <- 3 # classes
n <- npc * Q # nodes
Z<-diag(Q)%x%matrix(1,npc,1)
P<-matrix(runif(Q*Q),Q,Q)
M<-1*(matrix(runif(n*n),n,n)<Z%*%P%*%t(Z)) ## adjacency matrix
fit <- BM_bernoulli("SBM",M, plotting='')
out = A_P_from_blockmodels(model=fit)
csgc(out$A, out$P, out$modeltype)$t
```
We can also use "greed" package to do model fitting for SBM and DCSBM.

```{r greed1}
data(Books)
sbm = greed(Books$X, model = Sbm())
out1 = A_P_from_greed(data=Books$X, blockmodel=sbm)
csgc(out1$A, out1$P, out1$modeltype)$t
```

```{r greed2}
data(karate)
dcsbm = greed(karate, model= DcSbm())
out2 = A_P_from_greed(data=karate, blockmodel=dcsbm)
csgc(out2$A, out2$P, out2$modeltype)$t
```
